#!/usr/bin/env python

"""Python module for executing automated tests by Ops CI pipeline"""
import os
import sys
import re
import platform
from subprocess import Popen, PIPE, STDOUT
from argparse import ArgumentParser

try:
    import configparser  # Python 3
except:
    import ConfigParser as configparser  # Python 2


# path to services-test root dir
PATH_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))


def main(argv=None):
    options = arg_parser()
    if not options.project:
        header('ERROR')
        exit('no project specified. ABORTING!')

    path_root, tests = directory_list(options.project)

    # run script requires that the test_env (dev, stage, pre-prod, prod, etc.)
    # be passed in via an env var
    # correct test_env name(s) will not be enforced as there may be some
    # custom test_env names in future
    if options.test_env:
        os.environ["test_env"] = options.test_env.lower()
    else:
        header('ERROR')
        exit('no test-env specified. ABORTING!')

    run_tests(path_root, tests)


def arg_parser(argv=None):

    if argv is None:
        argv = sys.argv

    conf_parser = ArgumentParser(prog='ci-test-run')

    conf_parser.add_argument("-p", "--project",
                             help="Provide a project name")
    conf_parser.add_argument("-e", "--test-env",
                             help="Provide the environment to test in\n"
                             "i.e.: dev, stage, prod")
    return conf_parser.parse_args()


def directory_list(path_parent_dir):
    """Return list of child directories.
    Input:
        path of parent directory
    """
    path_root = PATH_ROOT
    if path_parent_dir:
        #path_root = '{0}/{1}'.format(PATH_ROOT, path_parent_dir)
        path_root = os.path.join(PATH_ROOT, path_parent_dir)
        print('PATH ROOT: '.format(path_root))
    items = os.walk(path_root).next()[1]
    return path_root, [item for item in items if not item.startswith(('_', '.'))]  # noqa


def run_tests(path_root, tests):
    header('RUN TESTS', '*', 60)

    this_os = get_os()

    for test in tests:
        path_jenkins = '{0}/{1}/jenkins.ini'.format(path_root, test)

        # returns either None or ci_label
        slave_label = parse_jenkins_conf(path_jenkins)
        
        if slave_label is not None:
            path_test = '{0}/{1}/run'.format(path_root, test)
            if this_os == 'win' and slave_label == 'WIN-SERVER':
                local(path_test)
            elif this_os == 'linux' and slave_label == 'UBUNTU-DESKTOP':
                local(path_test)
            elif this_os == 'mac' and slave_label == 'OSX':
                local(path_test)
        else:
            header('ERROR')
            print('no slave label found. ABORTING!')


def parse_jenkins_conf(path_jenkins_conf):
    header('PARSE JENKINS.INI', '=', 45)
    if not os.path.isfile(path_jenkins_conf):
        print 'no jenkins.ini found!\n'
        return None

    config = configparser.ConfigParser()
    config.read(path_jenkins_conf)
    if config.has_section('ci'):
        ci_enabled = config.getboolean('ci', 'enabled')
        if ci_enabled:
            print('ci enabled!')
            if config.has_option('ci', 'label'):
                ci_label = config.get('ci', 'label')
                print('found slave label: {0}'.format(ci_label))
                return ci_label
            else:
                print('no slave label found!')
                return None
        else:
            print('ci NOT enabled!')
            return None
    else:
        print('ci section not found in jenkins.ini')
        return None


def get_os():
    system = platform.system().lower()
    system = re.split('[-_]', system, maxsplit=1).pop(0)

    if system == "cygwin":
        return "windows"
    if system == "darwin":
        return "mac"

    # default: linux or undefined
    return system


def local(cmd):
    proc = Popen(cmd, stdout=PIPE, stderr=STDOUT, shell=True)
    for line in iter(proc.stdout.readline, b''):
        print(line.strip())
    proc.stdout.close()


def header(label, hdr_char='-', hdr_size=30):
    header_line = hdr_char * hdr_size
    print('{0}\n{1}\n{0}\n'.format(header_line, label))


if __name__ == "__main__":
    main()
